(window.webpackJsonp=window.webpackJsonp||[]).push([["vendors~home~polis~service"],{"./node_modules/scrollbooster/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/scrollbooster/src/index.js ***!
  \*************************************************/
/*! exports provided: default */function(t,i,e){"use strict";e.r(i),e.d(i,"default",(function(){return o}));const s=t=>Math.max(t.offsetHeight,t.scrollHeight);class o{constructor(t={}){const i={content:t.viewport.children[0],direction:"all",pointerMode:"all",scrollMode:void 0,bounce:!0,bounceForce:.1,friction:.05,textSelection:!1,inputsFocus:!0,emulateScroll:!1,preventDefaultOnEmulateScroll:!1,preventPointerMoveDefault:!0,lockScrollOnDragDirection:!1,pointerDownPreventDefault:!0,dragDirectionTolerance:40,onPointerDown(){},onPointerUp(){},onPointerMove(){},onClick(){},onUpdate(){},onWheel(){},shouldScroll:()=>!0};if(this.props={...i,...t},!(this.props.viewport&&this.props.viewport instanceof Element))return void console.error('ScrollBooster init error: "viewport" config property must be present and must be Element');if(!this.props.content)return void console.error("ScrollBooster init error: Viewport does not have any content");this.isDragging=!1,this.isTargetScroll=!1,this.isScrolling=!1,this.isRunning=!1;const e={x:0,y:0};this.position={...e},this.velocity={...e},this.dragStartPosition={...e},this.dragOffset={...e},this.clientOffset={...e},this.dragPosition={...e},this.targetPosition={...e},this.scrollOffset={...e},this.rafID=null,this.events={},this.updateMetrics(),this.handleEvents()}updateOptions(t={}){this.props={...this.props,...t},this.props.onUpdate(this.getState()),this.startAnimationLoop()}updateMetrics(){var t;this.viewport={width:this.props.viewport.clientWidth,height:this.props.viewport.clientHeight},this.content={width:(t=this.props.content,Math.max(t.offsetWidth,t.scrollWidth)),height:s(this.props.content)},this.edgeX={from:Math.min(-this.content.width+this.viewport.width,0),to:0},this.edgeY={from:Math.min(-this.content.height+this.viewport.height,0),to:0},this.props.onUpdate(this.getState()),this.startAnimationLoop()}startAnimationLoop(){this.isRunning=!0,cancelAnimationFrame(this.rafID),this.rafID=requestAnimationFrame(()=>this.animate())}animate(){if(!this.isRunning)return;this.updateScrollPosition(),this.isMoving()||(this.isRunning=!1,this.isTargetScroll=!1);const t=this.getState();this.setContentPosition(t),this.props.onUpdate(t),this.rafID=requestAnimationFrame(()=>this.animate())}updateScrollPosition(){this.applyEdgeForce(),this.applyDragForce(),this.applyScrollForce(),this.applyTargetForce();const t=1-this.props.friction;this.velocity.x*=t,this.velocity.y*=t,"vertical"!==this.props.direction&&(this.position.x+=this.velocity.x),"horizontal"!==this.props.direction&&(this.position.y+=this.velocity.y),this.props.bounce&&!this.isScrolling||this.isTargetScroll||(this.position.x=Math.max(Math.min(this.position.x,this.edgeX.to),this.edgeX.from),this.position.y=Math.max(Math.min(this.position.y,this.edgeY.to),this.edgeY.from))}applyForce(t){this.velocity.x+=t.x,this.velocity.y+=t.y}applyEdgeForce(){if(!this.props.bounce||this.isDragging)return;const t=this.position.x<this.edgeX.from,i=this.position.x>this.edgeX.to,e=this.position.y<this.edgeY.from,s=this.position.y>this.edgeY.to,o=t||i,n=e||s;if(!o&&!n)return;const r=t?this.edgeX.from:this.edgeX.to,h=e?this.edgeY.from:this.edgeY.to,p=r-this.position.x,a=h-this.position.y,l={x:p*this.props.bounceForce,y:a*this.props.bounceForce},c=this.position.x+(this.velocity.x+l.x)/this.props.friction,g=this.position.y+(this.velocity.y+l.y)/this.props.friction;(t&&c>=this.edgeX.from||i&&c<=this.edgeX.to)&&(l.x=p*this.props.bounceForce-this.velocity.x),(e&&g>=this.edgeY.from||s&&g<=this.edgeY.to)&&(l.y=a*this.props.bounceForce-this.velocity.y),this.applyForce({x:o?l.x:0,y:n?l.y:0})}applyDragForce(){if(!this.isDragging)return;const t=this.dragPosition.x-this.position.x,i=this.dragPosition.y-this.position.y;this.applyForce({x:t-this.velocity.x,y:i-this.velocity.y})}applyScrollForce(){this.isScrolling&&(this.applyForce({x:this.scrollOffset.x-this.velocity.x,y:this.scrollOffset.y-this.velocity.y}),this.scrollOffset.x=0,this.scrollOffset.y=0)}applyTargetForce(){this.isTargetScroll&&this.applyForce({x:.08*(this.targetPosition.x-this.position.x)-this.velocity.x,y:.08*(this.targetPosition.y-this.position.y)-this.velocity.y})}isMoving(){return this.isDragging||this.isScrolling||Math.abs(this.velocity.x)>=.01||Math.abs(this.velocity.y)>=.01}scrollTo(t={}){this.isTargetScroll=!0,this.targetPosition.x=-t.x||0,this.targetPosition.y=-t.y||0,this.startAnimationLoop()}setPosition(t={}){this.velocity.x=0,this.velocity.y=0,this.position.x=-t.x||0,this.position.y=-t.y||0,this.startAnimationLoop()}getState(){return{isMoving:this.isMoving(),isDragging:!(!this.dragOffset.x&&!this.dragOffset.y),position:{x:-this.position.x,y:-this.position.y},dragOffset:this.dragOffset,dragAngle:this.getDragAngle(this.clientOffset.x,this.clientOffset.y),borderCollision:{left:this.position.x>=this.edgeX.to,right:this.position.x<=this.edgeX.from,top:this.position.y>=this.edgeY.to,bottom:this.position.y<=this.edgeY.from}}}getDragAngle(t,i){return Math.round(Math.atan2(t,i)*(180/Math.PI))}getDragDirection(t,i){return Math.abs(90-Math.abs(t))<=90-i?"horizontal":"vertical"}setContentPosition(t){"transform"===this.props.scrollMode&&(this.props.content.style.transform=`translate(${-t.position.x}px, ${-t.position.y}px)`),"native"===this.props.scrollMode&&(this.props.viewport.scrollTop=t.position.y,this.props.viewport.scrollLeft=t.position.x)}handleEvents(){const t={x:0,y:0},i={x:0,y:0};let e=null,s=null,o=!1;const n=s=>{if(!this.isDragging)return;const n=o?s.touches[0]:s,{pageX:r,pageY:h,clientX:p,clientY:a}=n;this.dragOffset.x=r-t.x,this.dragOffset.y=h-t.y,this.clientOffset.x=p-i.x,this.clientOffset.y=a-i.y,(Math.abs(this.clientOffset.x)>5&&!e||Math.abs(this.clientOffset.y)>5&&!e)&&(e=this.getDragDirection(this.getDragAngle(this.clientOffset.x,this.clientOffset.y),this.props.dragDirectionTolerance)),this.props.lockScrollOnDragDirection&&"all"!==this.props.lockScrollOnDragDirection?e===this.props.lockScrollOnDragDirection&&o?(this.dragPosition.x=this.dragStartPosition.x+this.dragOffset.x,this.dragPosition.y=this.dragStartPosition.y+this.dragOffset.y):o?(this.dragPosition.x=this.dragStartPosition.x,this.dragPosition.y=this.dragStartPosition.y):(this.dragPosition.x=this.dragStartPosition.x+this.dragOffset.x,this.dragPosition.y=this.dragStartPosition.y+this.dragOffset.y):(this.dragPosition.x=this.dragStartPosition.x+this.dragOffset.x,this.dragPosition.y=this.dragStartPosition.y+this.dragOffset.y)};this.events.pointerdown=e=>{o=!(!e.touches||!e.touches[0]),this.props.onPointerDown(this.getState(),e,o);const s=o?e.touches[0]:e,{pageX:r,pageY:h,clientX:p,clientY:a}=s,{viewport:l}=this.props,c=l.getBoundingClientRect();if(p-c.left>=l.clientLeft+l.clientWidth)return;if(a-c.top>=l.clientTop+l.clientHeight)return;if(!this.props.shouldScroll(this.getState(),e))return;if(2===e.button)return;if("mouse"===this.props.pointerMode&&o)return;if("touch"===this.props.pointerMode&&!o)return;if(!(this.props.inputsFocus&&["input","textarea","button","select","label"].indexOf(e.target.nodeName.toLowerCase())>-1)){if(this.props.textSelection){if(((t,i,e)=>{const s=t.childNodes,o=document.createRange();for(let t=0;t<s.length;t++){const n=s[t];if(3!==n.nodeType)continue;o.selectNodeContents(n);const r=o.getBoundingClientRect();if(i>=r.left&&e>=r.top&&i<=r.right&&e<=r.bottom)return n}return!1})(e.target,p,a))return;(()=>{const t=window.getSelection?window.getSelection():document.selection;t&&(t.removeAllRanges?t.removeAllRanges():t.empty&&t.empty())})()}this.isDragging=!0,t.x=r,t.y=h,i.x=p,i.y=a,this.dragStartPosition.x=this.position.x,this.dragStartPosition.y=this.position.y,n(e),this.startAnimationLoop(),!o&&this.props.pointerDownPreventDefault&&e.preventDefault()}},this.events.pointermove=t=>{!t.cancelable||"all"!==this.props.lockScrollOnDragDirection&&this.props.lockScrollOnDragDirection!==e||t.preventDefault(),n(t),this.props.onPointerMove(this.getState(),t,o)},this.events.pointerup=t=>{this.isDragging=!1,e=null,this.props.onPointerUp(this.getState(),t,o)},this.events.wheel=t=>{const i=this.getState();this.props.emulateScroll&&(this.velocity.x=0,this.velocity.y=0,this.isScrolling=!0,this.scrollOffset.x=-t.deltaX,this.scrollOffset.y=-t.deltaY,this.props.onWheel(i,t),this.startAnimationLoop(),clearTimeout(s),s=setTimeout(()=>this.isScrolling=!1,80),this.props.preventDefaultOnEmulateScroll&&this.getDragDirection(this.getDragAngle(-t.deltaX,-t.deltaY),this.props.dragDirectionTolerance)===this.props.preventDefaultOnEmulateScroll&&t.preventDefault())},this.events.scroll=()=>{const{scrollLeft:t,scrollTop:i}=this.props.viewport;Math.abs(this.position.x+t)>3&&(this.position.x=-t,this.velocity.x=0),Math.abs(this.position.y+i)>3&&(this.position.y=-i,this.velocity.y=0)},this.events.click=t=>{const i=this.getState(),e="vertical"!==this.props.direction?i.dragOffset.x:0,s="horizontal"!==this.props.direction?i.dragOffset.y:0;Math.max(Math.abs(e),Math.abs(s))>5&&(t.preventDefault(),t.stopPropagation()),this.props.onClick(i,t,o)},this.events.contentLoad=()=>this.updateMetrics(),this.events.resize=()=>this.updateMetrics(),this.props.viewport.addEventListener("mousedown",this.events.pointerdown),this.props.viewport.addEventListener("touchstart",this.events.pointerdown,{passive:!1}),this.props.viewport.addEventListener("click",this.events.click),this.props.viewport.addEventListener("wheel",this.events.wheel,{passive:!1}),this.props.viewport.addEventListener("scroll",this.events.scroll),this.props.content.addEventListener("load",this.events.contentLoad,!0),window.addEventListener("mousemove",this.events.pointermove),window.addEventListener("touchmove",this.events.pointermove,{passive:!1}),window.addEventListener("mouseup",this.events.pointerup),window.addEventListener("touchend",this.events.pointerup),window.addEventListener("resize",this.events.resize)}destroy(){this.props.viewport.removeEventListener("mousedown",this.events.pointerdown),this.props.viewport.removeEventListener("touchstart",this.events.pointerdown),this.props.viewport.removeEventListener("click",this.events.click),this.props.viewport.removeEventListener("wheel",this.events.wheel),this.props.viewport.removeEventListener("scroll",this.events.scroll),this.props.content.removeEventListener("load",this.events.contentLoad),window.removeEventListener("mousemove",this.events.pointermove),window.removeEventListener("touchmove",this.events.pointermove),window.removeEventListener("mouseup",this.events.pointerup),window.removeEventListener("touchend",this.events.pointerup),window.removeEventListener("resize",this.events.resize)}}}}]);